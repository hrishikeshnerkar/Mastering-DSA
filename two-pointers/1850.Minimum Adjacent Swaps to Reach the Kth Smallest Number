class Solution {
    // Main method to get minimum swaps to reach the k-th permutation of the number
    public int getMinSwaps(String num, int k) {
        // Convert input string to character array
        char[] target = num.toCharArray();

        // Generate the k-th next permutation
        for(int i = 0; i < k; i++){
            nextPerm(target);
        }

        // Convert original number to character array
        char[] nums = num.toCharArray();

        // Calculate minimum swaps needed to convert nums to target
        return minSwaps(nums, target, nums.length);
    }

    // Reverse the array from index i to the end
    public void reverse(char[] nums, int i){
        int j = nums.length - 1;
        while(i < j){
            swap(nums, i, j);
            i++;
            j--;
        }
    }

    // Swap two characters in the array
    public void swap(char[] nums, int i, int j){
        char temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    // Generate the next lexicographical permutation of the array
    public void nextPerm(char[] nums){
        if(nums.length == 0) return;
        int len = nums.length;

        // Traverse from right to left to find the first decreasing element
        for(int i = len - 1; i >= 1; i--){
            if(nums[i] > nums[i - 1]){
                // Reverse the suffix starting from index i
                reverse(nums, i);

                // Find the smallest element greater than nums[i - 1] and swap
                for(int j = i; j < len; j++){
                    if(nums[j] > nums[i - 1]){
                        swap(nums, i - 1, j);
                        return;
                    }
                }
            }
        }

        // If no next permutation is found, reverse the entire array
        reverse(nums, 0);
    }

    // Calculate minimum adjacent swaps to convert nums to target
    public int minSwaps(char[] nums, char[] target, int size){
        int swaps = 0;

        // Traverse each character
        for(int i = 0; i < size; i++){
            int j = i;

            // Find the position in nums where target[i] is located
            while(nums[j] != target[i]) j++;

            // Swap adjacent characters to bring target[i] to position i
            while(i < j){
                swap(nums, j, j - 1);
                j--;
                swaps++;
            }
        }

        // Return total number of swaps
        return swaps;
    }
}
