// First Approach using two pointers and inorder brute force

class Solution {
    public boolean findTarget(TreeNode root, int k) {
        List<Integer> nums = new ArrayList<>();
        inorder(root, nums);
        int left = 0, right = nums.size()-1;
        while(left < right){
            int sum = nums.get(right) + nums.get(left);
            if(sum == k) return true;
            if(sum < k) left++;
            else right--;
        }
        return false;
    }

    public void inorder(TreeNode root, List<Integer> nums){
        if(root == null) return;
        inorder(root.left, nums);
        nums.add(root.val);
        inorder(root.right, nums);
    }
}


// Second Approach using hashset and preorder logic

class Solution {
    public boolean findTarget(TreeNode root, int k) {
        Set<Integer> set = new HashSet<>();
        return preorder(root, set, k);
    }
    
    public boolean preorder(TreeNode root, Set<Integer> set, int k){
        if(root == null) return false;
        int Ele = k - root.val;
        if(set.contains(Ele)) return true;
        set.add(root.val);
        return preorder(root.left, set, k) || preorder(root.right, set, k);
    }
}